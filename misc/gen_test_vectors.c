/*
** Generate Test Vectors for libsodium. They are used in TestVector.java 
** in my libsodium-jna implemetation. The vectors are generated on a 
** 32 bit Linux system.
** muquit@muquit.com Oct-10-2016  - first cut
*/
#include <stdio.h>
#include <string.h>
#include <sodium.h>

#include <assert.h>

#define PASSWORD "Correct Horse Battery Staple"
#define MESSAGE ((const unsigned char *) "this is a test")

/*
** Just print bytes in hex
*/
static char *hexstr(unsigned char *data, int data_len)
{
    int hex_len = data_len * 2 + 1;
    char *hex = (char *) malloc(hex_len * sizeof(char));
    memset(hex,0,hex_len);
    sodium_bin2hex(hex,hex_len,data,data_len);
    return(hex);
}

static void print_footer(void)
{
    printf("}\n");
}

static void print_header()
{
    printf(
"package test.com.muquit.libsodiumjna;\n\n"
"/**\n"
" * Test Vectors for libsodium using v%s\n"
" * Auto Generated by gen_test_vectors for libsodium-jna\n"
" * By muquit@muquit.com\n"
" */\n\n"
"public class TestVectors\n"
"{\n"
"    public static final String PASSWORD_STR = \"%s\";\n"
"    public static final String MESSAGE_STR = \"%s\";\n"
"    public static final byte[] MESSAGE = MESSAGE_STR.getBytes();\n"
"    public static final byte[] PASSWORD = PASSWORD_STR.getBytes();\n",
    sodium_version_string(),
    PASSWORD,MESSAGE);

}

static void print_pwhash_argon2_vectors(void)
{
    int
        rc;
    unsigned char
        salt[crypto_pwhash_SALTBYTES],
        key[crypto_box_SEEDBYTES];

    randombytes_buf(salt, sizeof(salt));
    rc = crypto_pwhash(key, sizeof(key),
            PASSWORD, strlen(PASSWORD),
            salt,
            crypto_pwhash_OPSLIMIT_INTERACTIVE,
            crypto_pwhash_MEMLIMIT_INTERACTIVE,
            crypto_pwhash_ALG_DEFAULT);
    assert(rc == 0);



    printf(
"\n"
"// Password hashing Argon2\n"
"    public static final String PWHASH_ARGON2_SALT=\"%s\";\n"
"    public static final int    PWHASH_ARGON2_SALT_LEN=%d;\n"
"    public static final String PWHASH_ARGON2_KEY=\"%s\";\n"
"    public static final int    PWHASH_ARGON2_KEY_LEN=%d;\n"
"    public static final String SECRET_BOX_SALT=\"%s\";\n",
    hexstr(salt,sizeof(salt)),
    sizeof(salt),
    hexstr(key,sizeof(key)),
    sizeof(key),
    hexstr(salt,sizeof(salt)));
}

static void print_pwhash_argon2_password_storage_vectors(void)
{
    char
        hashed_password[crypto_pwhash_STRBYTES];
    int
        rc;

    rc = crypto_pwhash_str(hashed_password,
            PASSWORD, strlen(PASSWORD),
            crypto_pwhash_OPSLIMIT_INTERACTIVE,
            crypto_pwhash_MEMLIMIT_INTERACTIVE);
    assert(rc == 0);
    printf(
"\n"
"// Password storage\n"
"   public static final String PWHASH_ARGON2_HASHED_PASSWORD=\"%s\";\n",
        hashed_password);

}
static void print_pwhash_scrypt_vectors(void)
{
    int
        rc;

    unsigned char
        salt[crypto_pwhash_scryptsalsa208sha256_SALTBYTES],
        key[crypto_box_SEEDBYTES];

    memset(key,0,sizeof(key));
    randombytes_buf(salt, sizeof salt);

    rc = crypto_pwhash_scryptsalsa208sha256(key, sizeof(key),
            PASSWORD, strlen(PASSWORD),
            salt,
            crypto_pwhash_OPSLIMIT_INTERACTIVE,
            crypto_pwhash_MEMLIMIT_INTERACTIVE);
    assert(rc == 0);

    printf(
"\n"
"// Password hashing scrypt\n"
"    public static final String PWHASH_SCRYPT_SALT=\"%s\";\n"
"    public static final int    PWHASH_SCRYPT_SALT_LEN=%d;\n"
"    public static final String PWHASH_SCRYPT_KEY=\"%s\";\n"
"    public static final int    PWHASH_SCRYPT_KEY_LN=%d;\n",
    hexstr(salt,sizeof(salt)),
    sizeof(salt),
    hexstr(key,sizeof(key)),
    sizeof(key));

}

static void print_secret_key_vectors(void)
{
    int
        rc;
    unsigned char
        nonce[crypto_secretbox_NONCEBYTES],
        key[crypto_secretbox_KEYBYTES],
        mac[crypto_secretbox_MACBYTES],
        *ciphertext = NULL;

    int
        ciphertext_len;


    ciphertext_len = (crypto_secretbox_MACBYTES + strlen(MESSAGE)) * sizeof(unsigned char);
    ciphertext = (unsigned char *) malloc(ciphertext_len);
    assert(ciphertext != NULL);
    memset(ciphertext, 0, ciphertext_len);

    randombytes_buf(nonce, sizeof (nonce));
    randombytes_buf(key, sizeof (key));

    rc = crypto_secretbox_easy(ciphertext, MESSAGE, strlen(MESSAGE), nonce, key);
    printf(
"\n"
"// Secret-key authenticated encryption\n"
"    public static final String SECRET_BOX_NONCE=\"%s\";\n"
"    public static final int    SECRET_BOX_NONCE_LEN=%d;\n"
"    public static final String SECRET_BOX_KEY=\"%s\";\n"
"    public static final int    SECRET_BOX_KEY_LEN=%d;\n"
"    public static final String SECRET_BOX_CIPTHER_TEXT=\"%s\";\n"
"    public static final int    SECRET_BOX_CIPTHER_TEXT_LEN=%d;\n",
        hexstr(nonce,sizeof(nonce)),
        sizeof(nonce),
        hexstr(key,sizeof(key)),
        sizeof(key),
        hexstr(ciphertext,ciphertext_len),
        ciphertext_len);
    if (ciphertext)
        (void) free((char *) ciphertext);
    assert(rc == 0);

    /* detached mode */
    ciphertext_len = (strlen(MESSAGE)) * sizeof(unsigned char);
    ciphertext = (unsigned char *) malloc(ciphertext_len);
    assert(ciphertext != NULL);

    rc = crypto_secretbox_detached(ciphertext, mac,
            MESSAGE, strlen(MESSAGE), 
            nonce,key);
    assert(rc == 0);
    printf(
"     public static final String SECRET_BOX_DETACHED_MAC=\"%s\";\n"
"     public static final String SECRET_BOX_DETACHED_CIPHER_TEXT=\"%s\";\n"
"     public static final int    SECRET_BOX_DETACHED_CIPHER_TEXT_LEN=%d;\n"
"     public static final int    SECRET_BOX_DETACHED_MESSAGE_LEN=%d;\n",
        hexstr(mac,sizeof(mac)),
        hexstr(ciphertext,ciphertext_len),
        ciphertext_len,
        strlen(MESSAGE));
}

static void print_secret_key_auth_vectors(void)
{
    int
        rc;

    unsigned char
        key[crypto_auth_KEYBYTES],
        mac[crypto_auth_BYTES];

    randombytes_buf(key, sizeof(key));
    rc = crypto_auth(mac, MESSAGE, strlen(MESSAGE), key);
    assert(rc == 0);

    rc = crypto_auth_verify(mac, MESSAGE, strlen(MESSAGE), key);
    assert(rc == 0);
    printf(
"\n"
"// Secret-key authentication verification\n"
"   public static final String SECRET_KEY_AUTH_KEY=\"%s\";\n"
"   public static final String SECRET_KEY_AUTH_MAC=\"%s\";\n",
    hexstr(key,sizeof(key)),
    hexstr(mac,sizeof(mac)));

}

static void print_public_key_vectors(void)
{
    int
        rc;

    unsigned char
        nonce[crypto_box_NONCEBYTES],
        *ciphertext = NULL,
        *decrypted = NULL,
        alice_publickey[crypto_box_PUBLICKEYBYTES],
        alice_secretkey[crypto_box_SECRETKEYBYTES],
        bob_publickey[crypto_box_PUBLICKEYBYTES],
        bob_secretkey[crypto_box_SECRETKEYBYTES];

    int
        ciphertext_len;

    ciphertext_len = (crypto_secretbox_MACBYTES + strlen(MESSAGE)) * sizeof(unsigned char);
    ciphertext = (unsigned char *) malloc(ciphertext_len);
    assert(ciphertext != NULL);

    rc = crypto_box_keypair(alice_publickey, alice_secretkey);
    assert(rc == 0);

    rc = crypto_box_keypair(bob_publickey, bob_secretkey);
    assert(rc == 0);

    /* alice entrypts with bob's public key */
    rc = crypto_box_easy(ciphertext, MESSAGE, strlen(MESSAGE), 
            nonce,
            bob_publickey, alice_secretkey);
    assert(rc == 0);

    decrypted = (unsigned char *) malloc(strlen(MESSAGE) * sizeof(unsigned char *));
    assert(decrypted != NULL);

    /* bob decrypts with his private key */
    rc = crypto_box_open_easy(decrypted,
            ciphertext, ciphertext_len,
            nonce,
            alice_publickey, bob_secretkey);
    assert(rc == 0);


    printf(
"\n"
"// Public-key authenticated encryption\n"
"    public static final String CRYPTO_BOX_NONCE=\"%s\";\n"
"    public static final int    CRYPTO_BOX_NONCE_LEN=%d;\n"
"    public static final String CRYPTO_BOX_BOB_PUBLIC_KEY=\"%s\";\n"
"    public static final String CRYPTO_BOX_BOB_PRIVATE_KEY=\"%s\";\n"
"    public static final String CRYPTO_BOX_ALICE_PUBLIC_KEY=\"%s\";\n"
"    public static final String CRYPTO_BOX_ALICE_PRIVATE_KEY=\"%s\";\n"
"    public static final int    CRYPTO_BOX_KEY_LEN=%d;\n"
"    // Alice Encrypts with Bob's Public Key\n"
"    public static final String CRYPTO_BOX_ALICE_CIPHERTEXT=\"%s\";\n"
"    // Bob decrypt's with his private Key\n"
"    public static final String CRYPTO_BOX_BOB_PLAINTEXT=\"%s\";\n"
"    public static final int    CRYPTO_BOX_CIPHERTEXT_LEN=%d;\n",
        hexstr(nonce,sizeof(nonce)),
        sizeof(nonce),
        hexstr(bob_publickey,sizeof(bob_publickey)),
        hexstr(bob_secretkey,sizeof(bob_secretkey)),
        hexstr(alice_publickey,sizeof(alice_publickey)),
        hexstr(alice_secretkey,sizeof(alice_secretkey)),
        sizeof(bob_publickey),
        hexstr(ciphertext,ciphertext_len),
        hexstr(decrypted,strlen(MESSAGE)),
        ciphertext_len);

}

static void print_seal_box_vectors(void)
{
    unsigned char
        recipient_pk[crypto_box_PUBLICKEYBYTES],
        recipient_sk[crypto_box_SECRETKEYBYTES],
        *decrypted,
        *ciphertext = NULL;

    int
        rc,
        len,
        ciphertext_len;

    rc = crypto_box_keypair(recipient_pk, recipient_sk);
    assert(rc == 0);

    ciphertext_len = (crypto_box_SEALBYTES + strlen(MESSAGE)) * sizeof(unsigned char);
    ciphertext = (unsigned char *) malloc(ciphertext_len);
    assert(ciphertext != NULL);

    /*
    ** Anonymous sender encrypts a message using an ephemeral key pair
    ** and the recipient's public key
    */
    rc = crypto_box_seal(ciphertext,
            MESSAGE, strlen(MESSAGE),
            recipient_pk);
    assert(rc == 0);

    /* Recipient decrypts the ciphertext */
    decrypted = (unsigned char *) malloc(strlen(MESSAGE) * sizeof(unsigned char));
    assert(decrypted != NULL);
    rc = crypto_box_seal_open(decrypted,
        ciphertext, ciphertext_len,
        recipient_pk, recipient_sk);
    assert(rc == 0);

    /* ciphertext will be different each time */
    printf(
"\n"
"// Public-key authenticated encryption\n"
"    public static final String SEALBOX_RECIPIENT_PUBLIC_KEY=\"%s\";\n"
"    public static final String SEALBOX_RECIPIENT_PRIVATE_KEY=\"%s\";\n"
"    public static final int    SEALBOX_RECIPIENT_PUBLIC_KEY_LEN=%d;\n"
"    public static final int    SEALBOX_RECIPIENT_PRIVATE_KEY_LEN=%d;\n"
"    public static final String SEALBOX_CIPHERTEXT=\"%s\";\n"
"    public static final String SEALBOX_DECRYPTEDTEXT=\"%s\";\n"
"    public static final int    SEALBOX_CIPHERTEXT_LEN=%d;\n",
        hexstr(recipient_pk,sizeof(recipient_pk)),
        hexstr(recipient_sk,sizeof(recipient_sk)),
        sizeof(recipient_pk),
        sizeof(recipient_sk),
        hexstr(ciphertext,ciphertext_len),
        hexstr(decrypted,strlen(MESSAGE)),
        ciphertext_len);
            

}

static void print_generic_hash_vectors(void)
{
    unsigned char
        hash[crypto_generichash_BYTES];

    int
        rc;

    rc = crypto_generichash(hash, sizeof(hash),
            MESSAGE, strlen(MESSAGE),
            NULL, 0);
    assert(rc == 0);
}


int main(int argc,char *argv[])
{
    if (sodium_init() == -1)
    {
        return(1);
    }

    print_header();
    print_pwhash_argon2_vectors();
    print_pwhash_argon2_password_storage_vectors();
    print_pwhash_scrypt_vectors();
    print_secret_key_vectors();
    print_secret_key_auth_vectors();
    print_public_key_vectors();
    print_seal_box_vectors();
    print_generic_hash_vectors();
    print_footer();

    (void) fflush(stdout);

ExitProcessing:
    return(0);
}
